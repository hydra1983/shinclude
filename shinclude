#!/bin/bash

typeset -A BLOCK_PASS
typeset -a SHINCLUDE_PATH
SHINCLUDE_PATH=()
SHINCLUDE_PATH+=("$PWD")

#-----------------------------------
# BEGIN-INCLUDE src/logging.bash

## ## DIAGNOSTICS
##
## ### `$LOGLEVEL`
##
## Default: 0
##
## See [`-d`](#-d) and [`-dd`](#-dd)
##
LOGLEVEL=${LOGLEVEL:-0}

_debug() {
    level="$1"
    shift
    if ((LOGLEVEL >= level));then
        echo -e "# \e[35;1mDEBUG\e[39;0m $*" >&2
    fi
}

_error() {
    echo -e "\e[31;1mERROR\e[39;0m $*" >&2
    exit 2
}

# END-INCLUDE
# BEGIN-INCLUDE src/style.bash

# #### `$EXT_TO_RENDER_STYLE`
#
# Associative array of file extesions (w/o dot) to render method.
#
#       EXT_TO_RENDER_STYLE[md]="cat"
#       EXT_TO_RENDER_STYLE[sh]="doublepound"
#       EXT_TO_RENDER_STYLE[bash]="doublepound"
#
typeset -A EXT_TO_RENDER_STYLE
export EXT_TO_RENDER_STYLE=()

# #### `$EXT_TO_COMMENT_STYLE`
#
# Associative array of file extesions (w/o dot) to comment style.
#
#       EXT_TO_COMMENT_STYLE[md]="markdown"
#       EXT_TO_COMMENT_STYLE[markdown]="markdown"
#       EXT_TO_COMMENT_STYLE[ronn]="markdown"
#
typeset -A EXT_TO_COMMENT_STYLE
export EXT_TO_COMMENT_STYLE=()

# #### `$COMMENT_STYLE_START`
#
# Associative array of comment start strings for select languages
#
#       COMMENT_STYLE_START[html]="<!--"
#
typeset -A COMMENT_STYLE_START
export COMMENT_STYLE_START=()

# #### `$COMMENT_STYLE_END`
#
# Associative array of comment start strings for select languages
#
#       COMMENT_STYLE_END[html]="-->"
#
typeset -A COMMENT_STYLE_END
export COMMENT_STYLE_END=()

# #### `$RENDER_STYLE`
#
# Shell command to RENDER by extension
#
#     RENDER_STYLE[perl]="grep '^#='"
#
typeset -A RENDER_STYLE
export RENDER_STYLE=()

##
## ## RENDER STYLES
##

## ### cat
##
## * Echo the lines. Just like INCLUDE
##
## File Extensions:
##
## * `*.md`
## * `*.markdown`
## * `*.ronn`
## * `*.txt`
##
RENDER_STYLE[cat]="cat '%s'"
EXT_TO_RENDER_STYLE[md]="cat"
EXT_TO_RENDER_STYLE[markdown]="cat"
EXT_TO_RENDER_STYLE[ronn]="cat"
EXT_TO_RENDER_STYLE[txt]="cat"

## ### doublepound
##
##   * Prefix comments to render with `##`
##   * Replace `__CURLINE__` with current line
##   * Replace `__CURLINE__` with current line
##
## File Extensions:
##
##   * `*.sh`
##   * `*.bash`
##
RENDER_STYLE[doublepound]="awk '{gsub(\"__CURLINE__\",NR,\$0);print}' '%s'|grep '^\\s*##'|sed 's/^\\s*## \\\?//'"
EXT_TO_RENDER_STYLE[sh]="doublepound"
EXT_TO_RENDER_STYLE[zsh]="doublepound"
EXT_TO_RENDER_STYLE[bash]="doublepound"

## ### jade
##
## Render style:
##
##   * Run through `jade` template engine
##
## Extensions:
##
##   * `*.jade`
##   * `*.pug`
##
RENDER_STYLE[jade]="jade -P < '%s'|sed -n '2,\$p'"
EXT_TO_RENDER_STYLE[jade]="jade"
EXT_TO_RENDER_STYLE[pug]="jade"

##
## ## COMMENT STYLES
##

## ### xml
##
## Comment style:
##
##       <!-- BEGIN-... -->
##       <!-- END-... -->
##
COMMENT_STYLE_START[xml]="<!--"
COMMENT_STYLE_END[xml]="-->"
##
## File Extensions:
##
## * `.html`
## * `*.xml`
##
EXT_TO_COMMENT_STYLE[html]='xml'
EXT_TO_COMMENT_STYLE[xml]='xml'

## ### markdown
##
## Comment style:
##
##     []: BEGIN-...
##     []: END-...
##
COMMENT_STYLE_START[markdown]="[]:"
COMMENT_STYLE_END[markdown]=""
##
## Extensions:
##   * `*.ronn`
##   * `*.md`
##
EXT_TO_COMMENT_STYLE[md]='markdown'
EXT_TO_COMMENT_STYLE[markdown]='markdown'
EXT_TO_COMMENT_STYLE[ronn]='markdown'

## ### pound
##
## Comment style:
##
##     # BEGIN-...
##     # END-...
##
COMMENT_STYLE_START[pound]="#"
COMMENT_STYLE_END[pound]=""
## Extensions:
##
##   * `*.sh`
##   * `*.bash`
##   * `*.zsh`
##   * `*.py`
##   * `*.pl`
##   * `*.PL`
##   * `*.coffee`
##
EXT_TO_COMMENT_STYLE[sh]='pound'
EXT_TO_COMMENT_STYLE[bash]='pound'
EXT_TO_COMMENT_STYLE[zsh]='pound'
EXT_TO_COMMENT_STYLE[py]='pound'
EXT_TO_COMMENT_STYLE[pl]='pound'
EXT_TO_COMMENT_STYLE[PL]='pound'
EXT_TO_COMMENT_STYLE[coffee]='pound'

## ### slashstar
##
## Comment style:
##
##     /* BEGIN-... */
##     /* END-... */
##
## File Extensions:
##
## * `*.cpp`
## * `*.cxx`
## * `*.java`
##
EXT_TO_COMMENT_STYLE[cpp]='slashstar'
EXT_TO_COMMENT_STYLE[cxx]='slashstar'
EXT_TO_COMMENT_STYLE[java]='slashstar'
COMMENT_STYLE_START[slashstar]="/*"
COMMENT_STYLE_END[slashstar]="*/"

## ### doubleslash
##
## File Extensions:
##
##     // BEGIN-...
##     // END-...
##
COMMENT_STYLE_START[doubleslash]="//"
COMMENT_STYLE_END[doubleslash]=""
##
## File Extensions:
##
##   * `*.c`
##   * `*.js`
##
EXT_TO_COMMENT_STYLE[js]='doubleslash'
EXT_TO_COMMENT_STYLE[c]='doubleslash'

## ### doublequote
##
## Comment style:
##
##     " BEGIN-...
##     " END-...
##
COMMENT_STYLE_START[doublequote]="\""
COMMENT_STYLE_END[doubleslash]=""
##
## File Extensions:
##
## * `*.vim`
##
EXT_TO_COMMENT_STYLE[vim]='doublequote'

## ### doubleslashbang
##
## Comment style:
##
##     //! BEGIN-...
##     //! END-...
##
COMMENT_STYLE_START[doubleslashbang]="//!"
COMMENT_STYLE_END[doubleslashbang]=""
## Extensions:
##
##   * `*.jade`
##   * `*.pug`
##
EXT_TO_COMMENT_STYLE[jade]='doubleslashbang'
EXT_TO_COMMENT_STYLE[pug]='doubleslashbang'

# ### _detect_comment_style
# 
# Detect comment style by file extension. Default: 'xml'
#
#     _detect_comment_style "foo.md"    # -> 'markdown'
#     _detect_comment_style "foo.pl"    # -> 'pound'
#
_detect_comment_style() {
    local ext
    ext=${1##*.}
    if [[ ! -z "${EXT_TO_COMMENT_STYLE[$ext]}" ]];then
        echo "${EXT_TO_COMMENT_STYLE[$ext]}"
    else
        _debug 0 "Unknown extension $ext, defaulting to 'xml'"
        echo 'xml'
    fi
}

# END-INCLUDE
# BEGIN-INCLUDE src/block-EVAL.bash

## ### EVAL
##
## Evaluates the arguments as a shell expression. **BE CAREFUL**
##
## EVAL Runs on **first** pass
## 
##     # BEGIN-EVAL wc *
##     # END-EVAL
## 
## 
## will be transformed to
## 
##     # BEGIN-EVAL wc *
##
##       21   171  1085 LICENSE
##       51   106   978 Makefile
##      290   461  4058 README.md
##      558  1267 12212 shinclude
##      275   828  5565 shinclude.1
##     1723  4100 36080 total
##
##     # END-EVAL
##
typeset -A BLOCK_PASS
# shellcheck disable=2034
BLOCK_PASS[EVAL]=1

_block_EVAL() {
    local blockargs
    blockargs="$1"
    printf "%s" "$(eval "${blockargs//\//\/}")" 
}

# END-INCLUDE
# BEGIN-INCLUDE src/block-INCLUDE.bash

## ### INCLUDE
##
## Include data from a file.
##
## `INCLUDE` runs on **first** pass.
##
##     # BEGIN-INCLUDE LICENSE
##     # END-INCLUDE
##
## will be transformed to
##
##     # BEGIN-INCLUDE LICENSE
##     The MIT License (MIT)
##     
##     Copyright (c) 2016 Konstantin Baierer
##     
##     Permission is hereby granted, free of charge, to any person obtaining a copy
##     of this software and associated documentation files (the "Software"), to deal
##     in the Software without restriction, including without limitation the rights
##     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
##     copies of the Software, and to permit persons to whom the Software is
##     furnished to do so, subject to the following conditions:
##     
##     The above copyright notice and this permission notice shall be included in all
##     copies or substantial portions of the Software.
##     
##     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
##     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
##     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
##     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
##     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
##     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
##     SOFTWARE.
##     # END-INCLUDE
##
typeset -A BLOCK_PASS
# shellcheck disable=2034
BLOCK_PASS[INCLUDE]=1

_block_INCLUDE() {
    local blockargs includefile
    blockargs="$1"
    local IFS=$'\n'
    # shellcheck disable=2001
    for includefile in $(echo "$blockargs"|sed 's/,\s*/\n/g');do
        for dir in "${SHINCLUDE_PATH[@]}";do
            _debug 2 "INCLUDE: Trying $dir/$includefile"
            if [[ -e "$dir/$includefile" ]];then
                _debug 1 "INCLUDE: Including $includefile"
                cat "$dir/$includefile"
                break;
            fi
        done
    done
}

# END-INCLUDE
# BEGIN-INCLUDE src/block-RENDER.bash

## ### RENDER
##
## Renders a file to markdown using a [shell expression](#render_ext).
##
## The render method is determined by the file extension, see 
## [RENDER STYLES](#render-styles) for a list of render methods
##
## Runs on **first** pass
##
typeset -A BLOCK_PASS
# shellcheck disable=2034
BLOCK_PASS[RENDER]=1

_block_RENDER() {
    renderfile="$1"
    ext=${renderfile##*.}
    _debug 2 "RENDER: extension == '$ext'"
    style="${EXT_TO_RENDER_STYLE[$ext]}"
    if [[ -z "$style" ]];then
        _error "Cannot render '$ext'. Define \$EXT_TO_RENDER_STYLE[$ext]."
    fi
    render="${RENDER_STYLE[$style]}"
    if [[ -z "$render" ]];then
        _error "Cannot render '$style'. Define \$RENDER_STYLE[$style]."
    fi
    # shellcheck disable=2059
    for dir in "${SHINCLUDE_PATH[@]}";do
        _debug 2 "RENDER: Trying $dir/$renderfile"
        if [[ -e "$dir/$renderfile" ]];then
            _debug 1 "RENDER: Rendering $dir/$renderfile"
            cmd=$(printf "${RENDER_STYLE[$style]}" "$dir/$renderfile")
            _debug 2 "RENDER: command == '$cmd'"
            output=$(eval "$cmd")
            if (( $? > 0 ));then
                _error "Rendering failed: $output"
            fi
            printf "%s" "$output"
            return
        fi
    done
    _error "No file found in includes: $renderfile"
}

# END-INCLUDE
# BEGIN-INCLUDE src/block-MARKDOWN-TOC.bash

## ### MARKDOWN-TOC
##
## ([source](./src/block-MARKDOWN-TOC.bash#L__CURLINE__), [test](./test/MARKDOWN-TOC))
##
## Reads in the file and outputs a table of contents of
## the markdown headings.

##
## Runs on **second** pass
##
typeset -A BLOCK_PASS
# shellcheck disable=2034
BLOCK_PASS[MARKDOWN-TOC]=2

##
##     # First Heading
##
##     [rem]: BEGIN-MARKDOWN-TOC
##     [rem]: END-MARKDOWN-TOC
##
##     ## Second-Level Heading
##
## will be transformed to (`shinclude -cs '[rem]:' -ce '' -`)
##
##     # First Heading
##
##     [rem]: BEGIN-MARKDOWN-TOC
##
##     * [First Heading](#first-heading)
##     	* [Second-Level  Heading](#second-level-heading)
##
##     [rem]: END-MARKDOWN-TOC
##
##     ## Second-Level Heading

## #### `$MARKDOWN_TOC_INDENT`
##
## String to indent a single level. Default: `\t`
##
MARKDOWN_TOC_INDENT=${MARKDOWN_TOC_INDENT:-	}

## #### `$HEADING_REGEX`
##
## Regex used to detect and tokenize headings.
##
## Default: `^(##+)\s*(.*)`
##
HEADING_REGEX='^(##+)\s*(.*)'

## #### Heading-to-Link algorithm
##
# shellcheck disable=2004
_heading_to_toc() {
    local heading indent link_text link_target
    pounds="$1"
    link_text="$2"
    _debug 2 "MARKDOWN-TOC: Link Text: '$link_text' Link level: ${#pounds}"
    ## Indentation: Concatenate `$MARKDOWN_TOC_INDENT` times  the number of leading `#`- 2
    ##
    indent=${pounds#\##}
    indent=${indent//\#/$MARKDOWN_TOC_INDENT}
    ## Link target: Start with Link Text
    ##
    ## * lowercase
    ## * remove `` $ ` ( ) . ,``
    ## * Replace all non-alphanumeric characters with `-`
    ## * If link target not used previously
    ## * then set `EXISTING_HEADINGS[$link_target]` to `1`
    ## * else increase `EXISTING_HEADINGS[$link_target]` by one and concatenate
    link_target="${link_text,,}"
    link_target="${link_target//[\$\`()\.,]/}"
    link_target="${link_target//[^A-Za-z0-9_]/-}"
    if [[ -z ${EXISTING_HEADINGS[$link_target]} ]];then
        EXISTING_HEADINGS["$link_target"]=1
    else
        link_target="${link_target}-${EXISTING_HEADINGS[$link_target]}"
        (( EXISTING_HEADINGS[${link_target%-*}] += 1 ))
    fi
    printf "%s* [%s](#%s)\n" \
        "$indent" \
        "$link_text" \
        "$link_target"
}

_block_MARKDOWN-TOC() {
    local blockargs block line infile
    typeset -A EXISTING_HEADINGS
    EXISTING_HEADINGS=()
    infile="$3"
    IFS=$'\n'
    while read line;do
        if [[ $line =~ $HEADING_REGEX ]];then
            _heading_to_toc "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
        fi
    done < "$infile"
    _debug 1 "MARKDOWN-TOC: $(declare -p EXISTING_HEADINGS)"
    # for mdline in
}

# END-INCLUDE
#-----------------------------------

# ### usage
#
# Show usage
#
usage() {
  echo "Usage: $0 [-h] [-c COMMENT_STYLE] [-i] <action> [input-file]"
  [[ ! -z "$1" ]] && echo -e "\n!! $* !!\n"
  echo '
  Input File:

    If input-file is "-", read from STDIN.
    If no input-file is given, assume "./README.md"'
}

# shellcheck disable=2094
_parse_lines() {
    local pass line begin end blocktype blockargs block infile
    pass=$1
    infile=$2
    IFS=$'\n'
    while read -r line;do
      if [[ "$line" = "$COMMENT_START BEGIN-"* ]];then
          begin="$line"

          blocktype="${begin:${#COMMENT_START}:${#line}}"
          blocktype="${blocktype##*BEGIN-}"
          blocktype="${blocktype%$COMMENT_END}"
          blocktype="${blocktype%% *}"

          blockargs="${begin:${#COMMENT_START}:${#line}}"
          blockargs="${blockargs#*BEGIN-$blocktype}"
          blockargs="${blockargs# }"
          blockargs="${blockargs% $COMMENT_END}"

          block=""
          while
              read -r line \
              && [[ "$line" != "$COMMENT_START END-$blocktype"* \
              && "$line" != *"END-$blocktype $COMMENT_END"   ]]
          do
              printf -v block "%s\n%s" "$block" "$line"
          done
          if ! declare -f -F "_block_$blocktype">/dev/null;then
              _error "No such block type '$blocktype'"
          fi
          if [[ ${BLOCK_PASS[$blocktype]} != $pass ]];then
              _debug 1 "PASS $pass: SKIP '$blocktype' '$blockargs'"
              printf "%s\n%s\n%s\n" "$begin" "$block" "$line"
              continue;
          fi
          _debug 1 "PASS $pass: RUN $blocktype '$blockargs'"
          _debug 2 "PASS $pass: RUN $blocktype '$blockargs' '$block'"
          printf "%s\n%s\n\n%s\n" \
              "$begin" \
              "$("_block_$blocktype" "$blockargs" "$block" "$infile")" \
              "$line"
      else
          _debug 2 "PASS $pass: (ign) $line"
          printf "%s\n" "$line"
      fi
    done < "$infile"
}

## ## OPTIONS
_parse_args() {

    while [[ "$1" != '-' && "$1" = -* ]];do
        case "$1" in
            -h)
                ## ### -h, --help
                ##
                ## help
                ##
                usage
                exit ;;
            -i|--inplace)
                ## ### -i, --inplace
                ##
                ## Edit the file in-place
                ##
                IN_PLACE=true 
                ;;
            -p|--shinclude-path)
                ## ### -p, --shinclude-path PATH
                ##
                ## Add path to path to look for `INCLUDE` and `RENDER`.
                ##
                ## Can be repeated to add multiple paths.
                ##
                ## Default: `("$PWD")`
                ##
                SHINCLUDE_PATH+=("$2"); shift
                ;;
            -c|--coment-style)
                ## ### -c, --comment-style COMMENT_STYLE
                ##
                ## Comment style. See [COMMENT STYLES](#comment-styles).
                ##
                COMMENT_STYLE="$2"; shift
                ;;
            -cs|--comment-start)
                ## ### -cs, --comment-start COMMENT_START
                ##
                ## Comment start. Overrides language-specific comment start.
                ##
                ## See [COMMENT STYLES](#comment-styles).
                ##
                COMMENT_START="$2"; shift
                ;;
            -ce|--comment-end)
                ## ### -ce, --comment-end COMMENT_END
                ##
                ## Comment end. Overrides language-specific comment end.
                ##
                ## See [COMMENT STYLES](#comment-styles).
                ##
                COMMENT_END="$2"; shift
                ;;
            -d|--info)
                ## ### -d, --info
                ##
                ## Enable debug logging ([`$LOGLEVEL=1`](#loglevel))
                ##
                # shellcheck disable=2034
                LOGLEVEL=1
                ;;
            -dd|--debug) 
                ## ### -dd, --debug
                ##
                ## Enable trace logging (`$LOGLEVEL=2`).
                ##
                # shellcheck disable=2034
                LOGLEVEL=2
                ;;
            -ddd|--trace) 
                ## ### -ddd, --trace
                ##
                ## Enable trace logging (`$LOGLEVEL=2`) and print every statement as it is executed.
                ##
                # shellcheck disable=2034
                LOGLEVEL=2
                set -x
                ;;
        esac
        shift
    done

    if [[ "$1" && "$1" == "-" ]] ; then infile=/dev/stdin
    elif [[ "$1"              ]] ; then infile="$1"
    elif [[ -e "README.md"    ]] ; then infile="README.md"
    else _error "No file or stdin passed"; fi

    if [[ $IN_PLACE && "$infile" = "/dev/stdin" ]];then
        usage "Cannot edit STDIN in-place"
        exit 1
    fi

    COMMENT_STYLE=${COMMENT_STYLE:-$(_detect_comment_style "$infile")}
    if [[ -z "$COMMENT_STYLE" ]];then
        _error "Unable to detect comment style."
    fi
    COMMENT_START=${COMMENT_START:-${COMMENT_STYLE_START[$COMMENT_STYLE]}}
    COMMENT_END=${COMMENT_END:-${COMMENT_STYLE_END[$COMMENT_STYLE]}}
    _debug 1 "COMMENT_STYLE=$COMMENT_STYLE"
    _debug 1 "COMMENT_START=$COMMENT_START"
    _debug 1 "COMMENT_END=$COMMENT_END"
    _debug 1 "infile=$infile"
}

#
# main
#

_parse_args "$@"

# first pass
tempfile1=$(mktemp --tmpdir)
_debug 1 "tempfile1=$tempfile1"
trap 'rm $tempfile1' EXIT INT TERM
_parse_lines 1 "$infile" > "$tempfile1"

# second pass
tempfile2=$(mktemp --tmpdir)
_debug 1 "tempfile2=$tempfile2"
trap 'rm $tempfile2' EXIT INT TERM
_parse_lines 2 "$tempfile1" > "$tempfile2"

if [[ $IN_PLACE ]];then
    cp "$tempfile2" "$infile"
else
    cat "$tempfile2"
fi
